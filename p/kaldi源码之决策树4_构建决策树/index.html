<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='kaldi source code of decision tree_4'><title>Kaldi源码之决策树4_构建决策树</title>

<link rel='canonical' href='https://cosmo1995.github.io/p/kaldi%E6%BA%90%E7%A0%81%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%914_%E6%9E%84%E5%BB%BA%E5%86%B3%E7%AD%96%E6%A0%91/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='Kaldi源码之决策树4_构建决策树'>
<meta property='og:description' content='kaldi source code of decision tree_4'>
<meta property='og:url' content='https://cosmo1995.github.io/p/kaldi%E6%BA%90%E7%A0%81%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%914_%E6%9E%84%E5%BB%BA%E5%86%B3%E7%AD%96%E6%A0%91/'>
<meta property='og:site_name' content='Cosmo'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='kaldi' /><meta property='article:tag' content='decison tree' /><meta property='article:published_time' content='2019-09-08T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2019-09-08T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="Kaldi源码之决策树4_构建决策树">
<meta name="twitter:description" content="kaldi source code of decision tree_4">
    </head>
    <body class="">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.body.dataset.scheme = 'dark';
        } else {
            document.body.dataset.scheme = 'light';
        }
    })();
</script><div class="container main-container flex on-phone--column extended article-page with-toolbar">
            <aside class="sidebar left-sidebar sticky">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header class="site-info">
        
            <figure class="site-avatar">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu874715197ebd8e5cb58e412c943f3434_12926_300x0_resize_q75_box.jpg" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                

                
            </figure>
        
        <h1 class="site-name"><a href="https://cosmo1995.github.io/">Cosmo</a></h1>
        <h2 class="site-description">Why not ask the Magic Conch</h2>
    </header>

    <ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        

        <li >
            <a href='/about'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        

        
            <li id="dark-mode-toggle">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <span>Dark Mode</span>
            </li>
        
    </ol>
</aside>

            <main class="main full-width">
    <div id="article-toolbar">
        <a href="https://cosmo1995.github.io/" class="back-home">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



            <span>Back</span>
        </a>
    </div>

    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/kaldi/" style="background-color: #2a9d8f; color: #fff;">
                kaldi
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/kaldi%E6%BA%90%E7%A0%81%E4%B9%8B%E5%86%B3%E7%AD%96%E6%A0%914_%E6%9E%84%E5%BB%BA%E5%86%B3%E7%AD%96%E6%A0%91/">Kaldi源码之决策树4_构建决策树</a>
    </h2>

    
    <h3 class="article-subtitle">
        kaldi source code of decision tree_4
    </h3>
    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">Sep 08, 2019</time>
    </footer></div>
</header>

    <section class="article-content">
    <p>到现在为止，程序<code>acc-tree-stats</code>累积好了构建决策树所需的统计量，程序<code>cluster-phones</code>和<code>compile-questions</code>自动生成好了构建决策树所需的问题集。我们根据sets.int生成好了roots.int文件，那么我们就可以开始构建决策树，对三音素GMM的状态进行绑定。这次笔记的主要内容是讲解Kaldi如何构建决策树，实现对三音素GMM状态的绑定。
在这个笔记中，首先我会介绍构建决策树的主程序<code>build-tree</code>和主函数<code>BuildTree</code>，然后介绍主函数中用到的核心函数<code>GetStubMap</code>和<code>SplitDecisionTree</code>。</p>
<h2 id="build-tree">build-tree</h2>
<ul>
<li>作用：构建决策树</li>
<li>输入：累积的统计量treeacc、问题集questions.qst、roots.int、topo</li>
<li>输出：决策树tree</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">build-tree <span class="nv">$context_opts</span> --verbose<span class="o">=</span><span class="m">1</span> --max-leaves<span class="o">=</span><span class="nv">$numleaves</span> <span class="se">\
</span><span class="se"></span>    --cluster-thresh<span class="o">=</span><span class="nv">$cluster_thresh</span> <span class="nv">$dir</span>/treeacc <span class="nv">$lang</span>/phones/roots.int <span class="se">\
</span><span class="se"></span>    <span class="nv">$dir</span>/questions.qst <span class="nv">$lang</span>/topo <span class="nv">$dir</span>/tree
</code></pre></div><ol>
<li>
<p>读取roots.int，得到</p>
<p>1)<code>vector&lt;vector&lt;int&gt;&gt; phone_sets</code>，其一个元素包含roots.int的一行上的所有音素</p>
<p>2)<code>vector&lt;bool&gt; is_shared_root</code>，其一个元素指明该行的音素是否共享三个HMM状态的决策树树根</p>
<p>3)<code>vector&lt;bool&gt; is_split_root</code>，其一个元素指明是否对该行音素对应的决策树树根进行划分</p>
</li>
<li>
<p>读取topo文件，得到保存HMM拓扑结构的对象<code>HmmTopology topo</code></p>
</li>
<li>
<p>读取treeacc，得到累积的统计量<code>BuildTreeStatsType stats</code></p>
</li>
<li>
<p>读取questions.qst，得到<code>Questions qo</code></p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span> <span class="n">phone2num_pdf_classes</span><span class="p">;</span>
<span class="n">topo</span><span class="p">.</span><span class="n">GetPhoneToNumPdfClasses</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phone2num_pdf_classes</span><span class="p">);</span>
</code></pre></div><p>调用<code>topo.GetPhoneToNumPdfClasses</code>得到<code>phone2num_pdf_classes</code>，其元素保存每个音素对应的HMM状态数。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">to_pdf</span> <span class="o">=</span> <span class="n">BuildTree</span><span class="p">(</span><span class="n">qo</span><span class="p">,</span>
                   <span class="n">phone_sets</span><span class="p">,</span>
                   <span class="n">phone2num_pdf_classes</span><span class="p">,</span>
                   <span class="n">is_shared_root</span><span class="p">,</span>
                   <span class="n">is_split_root</span><span class="p">,</span>
                   <span class="n">stats</span><span class="p">,</span>
                   <span class="n">thresh</span><span class="p">,</span>
                   <span class="n">max_leaves</span><span class="p">,</span>
                   <span class="n">cluster_thresh</span><span class="p">,</span>
                   <span class="n">P</span><span class="p">)</span>
</code></pre></div><p>调用<code>BuildTree</code>，返回保存整个大决策树的 <code>to_pdf</code></p>
<h2 id="buildtree">BuildTree</h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">EventMap</span> <span class="o">*</span><span class="n">tree_stub</span> <span class="o">=</span> <span class="n">GetStubMap</span><span class="p">(</span><span class="n">P</span>
                                 <span class="n">phone_sets</span>
                                 <span class="n">phone2num_pdf_classes</span>
                                 <span class="n">share_roots</span>
                                 <span class="o">&amp;</span><span class="n">num_leaves</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span> <span class="n">nonsplit_phones</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">phone_sets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_split</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">nonsplit_phones</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nonsplit_phones</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">phone_sets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">begin</span><span class="p">(),</span> <span class="n">phone_sets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">());</span>
<span class="p">...</span>
<span class="n">BuildTreeStatsType</span> <span class="n">filtered_stats</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nonsplit_phones</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="n">FilterStatsByKey</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">nonsplit_phones</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filtered_stats</span><span class="p">);</span> <span class="c1">//retain only those not in &#34;nonsplit_phones&#34;
</span><span class="c1"></span>
<span class="n">EventMap</span> <span class="o">*</span><span class="n">tree_split</span> <span class="o">=</span> <span class="n">SplitDecisionTree</span><span class="p">(</span><span class="o">*</span><span class="n">tree_stub</span><span class="p">,</span>
                                         <span class="n">nonsplit_phones</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">?</span> <span class="nl">stats</span> <span class="p">:</span> <span class="n">filtered_stats</span><span class="p">,</span>
                                         <span class="n">qopts</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">max_leaves</span><span class="p">,</span>
                                         <span class="o">&amp;</span><span class="n">num_leaves</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">impr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smallest_split</span><span class="p">);</span>
</code></pre></div><ul>
<li>调用<code>GetStubMap</code>得到初始的决策树<code>tree_stub</code>，也就是扩展前的决策树。扩展前的决策树的一个叶子结点对应roots.int中的一行的决策树的树根</li>
<li><code>FilterStatsByKey</code>过滤phone_sets中<code>not split</code>的元素</li>
<li>调用<code>SplitDecisionTree</code>，将<code>tree_stub</code>的每个叶子结点扩展成决策树，对每一个音素生成实际的决策树</li>
</ul>
<h4 id="getstubmap">GetStubMap</h4>
<ul>
<li>作用：构建初始决策树</li>
<li>输入：音素中间位置<code>P</code>、roots.int中每一行音素<code>phone_sets</code>、每个音素对应的HMM state数<code>phone2num_pdf_classes</code>、roots.int中每一行的三个HMM state是否共享树根<code>share_roots</code></li>
<li>输出：决策树<code>*tree_stub</code></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">EventMap</span> <span class="o">*</span><span class="nf">GetStubMap</span><span class="p">(</span><span class="n">int32</span> <span class="n">P</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">phone_sets</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">phone2num_pdf_classes</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">share_roots</span><span class="p">,</span>
                     <span class="n">int32</span> <span class="o">*</span><span class="n">num_leaves_out</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">phone_sets</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">share_roots</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span> 
        	<span class="k">return</span> <span class="k">new</span> <span class="n">ConstantEventMap</span><span class="p">(</span> <span class="p">(</span><span class="o">*</span><span class="n">num_leaves_out</span><span class="p">)</span><span class="o">++</span> <span class="p">);</span>
    	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
             <span class="p">...</span>
             <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">EventValueType</span><span class="p">,</span> <span class="n">EventAnswerType</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
             <span class="k">for</span> <span class="p">(</span><span class="n">EventAnswerType</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">max_len</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
                 <span class="n">m</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">num_leaves_out</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
              <span class="k">return</span> <span class="k">new</span> <span class="n">TableEventMap</span><span class="p">(</span><span class="n">kPdfClass</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span> <span class="c1">//split on hmm-position
</span><span class="c1"></span>             <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">max_set_size</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">phone_sets</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">highest_numbered_phone</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">EventValueType</span><span class="p">,</span> <span class="n">EventMap</span><span class="o">*&gt;</span> <span class="n">m</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">phone_sets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">phone_sets_tmp</span><span class="p">;</span>
            <span class="n">phone_sets_tmp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">phone_sets</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">share_roots_tmp</span><span class="p">;</span>
     		<span class="n">share_roots_tmp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">share_roots</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">EventMap</span> <span class="o">*</span><span class="n">this_stub</span> <span class="o">=</span> <span class="n">GetStubMap</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">phone_sets_tmp</span><span class="p">,</span> <span class="n">phone2num_pdf_classes</span><span class="p">,</span>
                                             <span class="n">share_roots_tmp</span><span class="p">,</span>
                                             <span class="n">num_leaves_out</span><span class="p">)</span>
            <span class="n">m</span><span class="p">[</span><span class="n">phone_sets_tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">this_stub</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">TableEventMap</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">size_t</span> <span class="n">half_sz</span> <span class="o">=</span> <span class="n">phone_sets</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">half_phones</span> <span class="o">=</span> <span class="n">phone_sets</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">half_sz</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">half_share</span> <span class="o">=</span> <span class="n">share_roots</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">half_sz</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int32</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">phone_sets_1</span><span class="p">,</span> <span class="n">phone_sets_2</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">share_roots_1</span><span class="p">,</span> <span class="n">share_roots_2</span><span class="p">;</span>
        <span class="n">phone_sets_1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">phone_sets_1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">phone_sets</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">half_phones</span><span class="p">);</span>
        <span class="n">phone_sets_2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">phone_sets_2</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">half_phones</span><span class="p">,</span> <span class="n">phone_sets</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="n">share_roots_1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">share_roots_1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">share_roots</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">half_share</span><span class="p">);</span>
        <span class="n">share_roots_2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">share_roots_2</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">half_share</span><span class="p">,</span> <span class="n">share_roots</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        
        <span class="n">EventMap</span> <span class="o">*</span><span class="n">map1</span> <span class="o">=</span> <span class="n">GetStubMap</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">phone_sets_1</span><span class="p">,</span> <span class="n">phone2num_pdf_classes</span><span class="p">,</span> <span class="n">share_roots_1</span><span class="p">,</span> <span class="n">num_leaves_out</span><span class="p">);</span>
        <span class="n">EventMap</span> <span class="o">*</span><span class="n">map2</span> <span class="o">=</span> <span class="n">GetStubMap</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">phone_sets_2</span><span class="p">,</span> <span class="n">phone2num_pdf_classes</span><span class="p">,</span> <span class="n">share_roots_2</span><span class="p">,</span> <span class="n">num_leaves_out</span><span class="p">);</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">EventKeyType</span><span class="o">&gt;</span> <span class="n">all_in_first_set</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">half_sz</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">phone_sets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                <span class="n">all_in_first_set</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">phone_sets</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">...</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">SplitEventMap</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">all_in_first_set</span><span class="p">,</span> <span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="p">);</span>
    <span class="p">}</span>
    
<span class="p">}</span>
</code></pre></div><p><code>phone_sets</code>的一个元素是roots.int的一行上的全部音素，roots.int有63行，则<code>phone_sets</code>有63个元素。</p>
<p>根据<code>phone_sets</code>可以分为三种情况：</p>
<ol>
<li>
<p><code>phone_sets</code>大小为1，此时进入第6行<code>if</code></p>
<ul>
<li>
<p>若该行音素为<code>shared</code>，则创建叶子结点<code>ConstantEventMap</code>，其<code>answer_</code>为<code>num_leaves_out</code>，结点创建后<code>num_leaves_out++</code></p>
</li>
<li>
<p>若该行音素为<code>not shared</code>，则首先获得所有音素的最大HMM state数<code>max_len</code>，<code>m</code>中保存每个HMM state的<code>num_leaves_out</code>，创建<code>TableEventMap</code>，</p>
<p>其<code>key_</code>为-1，<code>table_</code>为<code>m</code></p>
</li>
</ul>
</li>
<li>
<p><code>phone_sets</code>大小不为1，但是每个元素均只有1个音素，此时进入第16行<code>else if</code></p>
<ul>
<li>遍历<code>phone_sets</code>每个元素，调用<code>GetStubMap</code>，由于每个元素大小为1，进入情况1，返回<code>ConstantEventMap</code>结点，保存到<code>m</code>中</li>
<li>遍历结束后，<code>m</code>中保存了<code>phone_sets</code>每个音素及其对应的叶子结点<code>ConstantEventMap</code></li>
<li>创建<code>TableEventMap</code>，其<code>key_</code>为<code>P</code>，<code>table_</code>为<code>m</code></li>
</ul>
</li>
<li>
<p><code>phone_sets</code>不满足上述2中情况，此时进入第29行<code>else</code>。</p>
<ul>
<li>将<code>phone_sets</code>均分为两半<code>phone_sets_1</code>和<code>phone_sets_2</code>，<code>share_roots</code>同样分为两半<code>share_roots_1</code>和<code>share_roots_2</code>。将前后两半的<code>phone_sets</code>和<code>share_roots</code>作为参数递归调用<code>GetStubMap</code>，分别返回左右子树<code>map1</code>和<code>map2</code></li>
<li>创建<code>SplitEventMap</code>，其<code>key_</code>为<code>P</code>，<code>yes_set</code>为<code>phone_sets</code>前一半元素中所有的音素，<code>yes_</code>结点指向<code>map1</code>，<code>no_</code>结点指向<code>map2</code></li>
</ul>
</li>
</ol>
<p>调用<code>GetStubMap</code>生成的最终的决策树中叶子结点数等于roots.int行数，随后把每个叶子结点扩展成各自的决策树。</p>
<p><code>TableEventMap</code>作用：</p>
<p>从上面的过程我们发现，<code>SplitEventMap</code>每次划分我们只能创建两个孩子结点，包含63个元素的phone_sets要划分5次才能到达第一个叶子结点，太慢了。当某一次递归调用<code>GetStubMap</code>时我们发现<code>phone_sets</code>的大小不为一但是其每一个元素只包含一个音素，这时我们进入最外层的else if分支，生成一个TE。假设此时的<code>phone_sets</code>中保存的是roots.int的第41行到第46行，生成的TE的table_包含150个元素，第0到144个都为NULL，第145到150个都是CE，我们一下子生成了第41行到第46行对应的6个叶子结点，比用SE划分快多了。</p>
<h4 id="splitdecisiontree">SplitDecisionTree</h4>
<ul>
<li>作用：扩展原始决策树，构建完整决策树</li>
<li>输入：
<ul>
<li>原始决策树<code>input_map</code></li>
<li>roots.int中每一行统计量<code>stats</code></li>
<li>问题集<code>q_opts</code></li>
<li>决策树分裂导致的似然提升阈值<code>thresh</code></li>
<li>最大叶子结点数<code>max_leaves</code></li>
<li>roots.int中每一行对应的叶子结点<code>num_leaves</code></li>
</ul>
</li>
<li>输出：决策树<code>*tree_stub</code></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">EventMap</span> <span class="o">*</span><span class="nf">SplitDecisionTree</span><span class="p">(</span><span class="k">const</span> <span class="n">EventMap</span> <span class="o">&amp;</span><span class="n">input_map</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">BuildTreeStatsType</span> <span class="o">&amp;</span><span class="n">stats</span><span class="p">,</span>
                            <span class="n">Questions</span> <span class="o">&amp;</span><span class="n">q_opts</span><span class="p">,</span>
                            <span class="n">BaseFloat</span> <span class="n">thresh</span><span class="p">,</span>
                            <span class="n">int32</span> <span class="n">max_leaves</span><span class="p">,</span>  <span class="c1">// max_leaves&lt;=0 -&gt; no maximum.
</span><span class="c1"></span>                            <span class="n">int32</span> <span class="o">*</span><span class="n">num_leaves</span><span class="p">,</span>
                            <span class="n">BaseFloat</span> <span class="o">*</span><span class="n">obj_impr_out</span><span class="p">,</span>
                            <span class="n">BaseFloat</span> <span class="o">*</span><span class="n">smallest_split_change_out</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DecisionTreeSplitter</span><span class="o">*&gt;</span> <span class="n">builders</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BuildTreeStatsType</span><span class="o">&gt;</span> <span class="n">split_stats</span><span class="p">;</span>
        <span class="n">SplitStatsByMap</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="n">input_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">split_stats</span><span class="p">);</span>
        <span class="n">builders</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">split_stats</span><span class="p">.</span><span class="n">size</span><span class="p">));</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">split_stats</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">EventAnswerType</span> <span class="n">leaf</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">EventAnswerType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">split_stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">num_empty_leaves</span><span class="o">++</span><span class="p">;</span>
            <span class="n">builders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DecisionTreeSplitter</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">split_stats</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">q_opts</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>首先调用<code>SplitStatsByMap</code>，根据<code>tree_stub</code>对<code>stats</code>进行划分得到<code>split_stats</code>，将roots.int中同一行，即同一个叶子结点的统计量放在一起。</p>
<p>对<code>tree_stub</code>的每一个叶子结点初始化一个<code>DecisionTreeSplitter</code>对象，使用该对象构建叶子结点对应的决策树。我们注意到初始化<code>DecisionTreeSplitter</code>对象时传递的参数包括属于该叶子结点的统计量<code>split_stats[i]</code>、问题集<code>q_opts</code>，有这两者我们就可以构建起决策树。最终的<code>builders</code>包含63个<code>DecisionTreeSplitter</code>且一直包含63个<code>DecisionTreeSplitter</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">FindBestSplit</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">EventKeyType</span><span class="o">&gt;</span> <span class="n">all_keys</span><span class="p">;</span>
    <span class="n">q_opts_</span><span class="p">.</span><span class="n">GetKeysWithQuestions</span><span class="p">(</span><span class="o">&amp;</span><span class="n">all_keys</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">all_keys</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">q_opts_</span><span class="p">.</span><span class="n">HasQuestionsForKey</span><span class="p">(</span><span class="n">all_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">EventValueType</span><span class="o">&gt;</span> <span class="n">temp_yes_set</span><span class="p">;</span>
            <span class="n">BaseFloat</span> <span class="n">split_improvement</span> <span class="o">=</span> <span class="n">FindBestSplitForKey</span><span class="p">(</span><span class="n">stats_</span><span class="p">,</span> <span class="n">q_opts_</span><span class="p">,</span> <span class="n">all_keys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">temp_yes_set</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">split_improvement</span> <span class="o">&gt;</span> <span class="n">best_split_impr_</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">best_split_impr_</span> <span class="o">=</span> <span class="n">split_improvement</span><span class="p">;</span>
                <span class="n">yes_set_</span> <span class="o">=</span> <span class="n">temp_yes_set</span><span class="p">;</span>
                <span class="n">key_</span> <span class="o">=</span> <span class="n">all_keys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>DecisionTreeSplitter</code>对象初始化时，会调用<code>FindBestSplit</code>寻找该对象对应叶子结点的最优化分。<code>FindBestSplit</code>首先通过<code>GetKeysWithQuestions</code>获取问题集的所有<code>all_keys</code>（-1，0，1，2）。对于<code>all_keys</code>中每一个key，在该key对应的问题集中找到一个问题<code>FindBestSplitForKey</code>，使得对叶子结点划分后获得的似然提升<code>split_improvement</code>最大；现在对每个key都找到了该key对应的似然最大提升，然后比较这几个key的似然最大提升，再找出其中的最大似然提升<code>best_split_impr_</code>。将<code>DecisionTreeSplitter</code>的<code>key_</code>设置为似然提升最大的key；<code>yes_set_</code>设置为该key上取得最大似然提升的问题；<code>best_split_impr_</code>设置为 最大的似然提升。因为我们要对决策树进行持续划分，所以<code>DecisionTreeSplitter</code>还保存着指向两个子树的指针 <code>*yes_</code>, <code>*no_</code>。当第key个位置的音素属于<code>yes_set_</code>时进入<code>yes_</code>子树，否则进入<code>no_</code>子树。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"> <span class="p">{</span>  <span class="c1">// Do the splitting.
</span><span class="c1"></span>    <span class="n">int32</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">BaseFloat</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">queue</span><span class="p">;</span>  <span class="c1">// use size_t because logically these
</span><span class="c1"></span>    <span class="c1">// are just indexes into the array, not leaf-ids (after splitting they are no longer leaf id&#39;s).
</span><span class="c1"></span>    <span class="c1">// Initialize queue.
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">builders</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">builders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">BestSplit</span><span class="p">(),</span> <span class="n">i</span><span class="p">));</span>
    <span class="c1">// Note-- queue&#39;s size never changes from now.  All the alternatives leaves to split are
</span><span class="c1"></span>    <span class="c1">// inside the &#34;DecisionTreeSplitter*&#34; objects, in a tree structure.
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">first</span> <span class="o">&gt;</span> <span class="n">thresh</span>
          <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">max_leaves</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="o">||</span> <span class="o">*</span><span class="n">num_leaves</span> <span class="o">&lt;</span> <span class="n">max_leaves</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">smallest_split_change</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">smallest_split_change</span><span class="p">,</span> <span class="n">queue</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">first</span><span class="p">);</span>
      <span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
      <span class="n">like_impr</span> <span class="o">+=</span> <span class="n">queue</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
      <span class="n">builders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">DoSplit</span><span class="p">(</span><span class="n">num_leaves</span><span class="p">);</span>
      <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
      <span class="n">queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">builders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">BestSplit</span><span class="p">(),</span> <span class="n">i</span><span class="p">));</span>
      <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>把63个决策树（builders）放在一起比较，每次对似然提升最大的叶子结点进行划分，这种策略通过优先队列实现。划分具体就是指，对处于叶子位置的<code>DecisionTreeSplitter</code>找到第<code>key_</code>个位置和在该位置所问的问题<code>yes_set_</code>，同时将该<code>DecisionTreeSplitter</code>上的统计量根据划分结果分配到两个孩子<code>*yes_</code>和<code>*no_</code>。我们对所有的<code>builders</code>持续进行划分，在<code>tree_stub</code>的每个叶子结点就生成了一棵结点全是<code>DecisionTreeSplitter</code>的树。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">EventMap</span> <span class="o">*</span><span class="n">answer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">{</span>  <span class="c1">// Create the output EventMap.
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">EventMap</span><span class="o">*&gt;</span> <span class="n">sub_trees</span><span class="p">(</span><span class="n">builders</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sub_trees</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> 
        <span class="n">sub_trees</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">builders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">GetMap</span><span class="p">();</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="n">input_map</span><span class="p">.</span><span class="n">Copy</span><span class="p">(</span><span class="n">sub_trees</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sub_trees</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> 
        <span class="k">delete</span> <span class="n">sub_trees</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><p>对<code>tree_stub</code>的每个叶子结点，我们通过调用<code>GetMap</code>创建对应的子树，最终得到roots.int每一行的的决策树<code>sub_trees</code>。生成好属于roots.int每一行的决策树之后，通过<code>copy</code>对<code>tree_stub</code>进行扩展，把<code>tree_stub</code>中叶子结点替换成对应的子树<code>sub_trees</code>，于是，完整的大决策树就生成了。</p>
<h2 id="tree文件">tree文件</h2>
<pre><code>ContextDependency 3 1 ToPdf SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \
26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59\
 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 9\
3 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 1\
20 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 14\
5 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170\
 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 \
196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 ]
{ SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34\
 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 6\
8 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 10\
1 102 103 104 105 106 107 108 109 110 111 ]
{ SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34\
 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 ]
{ SE 1 [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ]
{ SE 1 [ 1 2 3 ]
{ TE -1 5 ( CE 0 CE 1 CE 2 CE 3 CE 4 )
SE -1 [ 0 ]
{ SE 2 [ 220 221 222 223 ]
{ SE 0 [ 104 105 106 107 112 113 114 115 172 173 174 175 208 209 210 211 212 213 214 215 264 265 266 \
267 280 281 282 283 284 285 286 287 ]
{ CE 5 CE 696 }
SE 2 [ 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 132 \
133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 248 249 250 251 252 253 254 255 256 257 2\
58 259 260 261 262 263 268 269 270 271 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 30\
3 ]
</code></pre><p>tree文件以对象的名字<code>ContextDependency</code>开始；然后是N（上下文窗的大小），这里是3；接着是P（上下文窗的中心位置），这里是1。</p>
<p>树顶层的<code>EventMap</code>是一个以<code>key_</code> 为1进行分裂的<code>SplitEventMap</code>，也就是按中心音素分裂。在方括号中是一系列连续范围的phone-ids。然而，这些并不表示一个问题，它们只是音素分裂的一种方法，因此我们可以得到每个音素真正的决策树。</p>
<p>文件后面的一些“SE”标签也是quasi-tree的一部分，它们都是首先按中心音素进行分裂（当我们顺着文件往下看时我们进入了树的更深处；注意这个花括号“{”一直是打开的，还没有关闭）。然后我们看到17行“TE -1 5 ( CE 0 CE 1 CE 2 CE 3 CE 4 ) ”，HMM状态5进行分裂，表示通过<code>TableEventMap</code>对pdf-class -1进行分裂，并且返回从0到4的值。这5个值表示的是静音和噪声音素SIL，NSN和SPN的5个pdf-ids。在我们的设定中，这三个非语音音素的pdfs是共享的（只有转移矩阵是不同的）。注意：对于这些音素我们用5状态而不是3状态的HMM，所以这里有5个不同的pdf-ids。</p>
<p>接下来18行是“SE -1 [ 0 ] ”，这可以被认为是这棵树中第一个真正的问题。是不是最左边的HMM-state,我们可以从上面的SE问题看出这个问题被应用于中心音素为4到19时候，也就是音素AA的不同版本（注：原文写的是5到19，不过我认为原文有问题，改成了4到19）。这个问题问的是pdf-class（key -1）是不是0（即是不是最左边的HMM-state）。下一个问题是“SE 2 [ 220 221 222 223 ]”，问的是音素右上下文是不是音素“M”不同形式中的一个（这是一个非常有效的问题，因为我们是在最左边的HMM-state）；如果问题的答案是yes，我们继续问“SE 0 [ 104 105 106 107… 286 287 ]”，这是一个关于音素左上下文的问题（注：原文写的是右上下文，但应该是左上下文）；如果答案是yes，则pdf-id就是5（“CE 5”），否则就是696（“CE 696”）。</p>
<pre><code>ContextDependency 1 0 ToPdf TE 0 49 ( NULL TE -1 3 ( CE 0 CE 1 CE 2 )
TE -1 3 ( CE 3 CE 4 CE 5 )
TE -1 3 ( CE 6 CE 7 CE 8 )
TE -1 3 ( CE 9 CE 10 CE 11 )
TE -1 3 ( CE 12 CE 13 CE 14 )
</code></pre><p>上面是一个更简单的例子。顶层的<code>EventMap</code>是一个<code>TableEventMap</code>（“TE 0 49 …”）。<code>key_</code> 0是音素位置0，表示中心（并且只有这一个）音素，因为上下文窗大小（N）为1。TE的条目数量是49（音素的数量加1）。表中第一个<code>EventMap</code>是NULL，因为没有序号为0的音素。下一个<code>EventMap</code>是一个有三个元素的<code>TableEventMap</code>，关联到第一个音素的三个HMM状态（技术上来说，是pdf-class）：“TE -1 3 ( CE 0 CE 1 CE 2 )”。</p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://blog.csdn.net/u010731824/article/details/69666560">https://blog.csdn.net/u010731824/article/details/69666560</a></li>
</ul>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/kaldi/">kaldi</a>
        
            <a href="/tags/decison-tree/">decison tree</a>
        
    </section>


    </footer>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
    integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
    integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
    integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="StackLaTeX()"></script>

<script>
    function StackLaTeX() {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });
    }
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
</aside>


    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2021 Cosmo
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.0.1">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css">
            </main>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"
    integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin="anonymous"></script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
